An extent catalog is very similar to a normal catalog except that it only
indexes items addable to its extent.  The extent is both a filter and a
set that may be merged with other result sets.

To show the extent catalog at work, we need an intid utility, an index,
some items to index, and a filter that determines what the extent accepts.

    >>> from zc.catalog import interfaces, extentcatalog
    >>> from zope import interface, component
    >>> from zope.interface import verify
    >>> import zope.app.intid.interfaces
    >>> class DummyIntId(object):
    ...     interface.implements(zope.app.intid.interfaces.IIntIds)
    ...     MARKER = '__dummy_int_id__'
    ...     def __init__(self):
    ...         self.counter = 0
    ...         self.data = {}
    ...     def register(self, obj):
    ...         intid = getattr(obj, self.MARKER, None)
    ...         if intid is None:
    ...             setattr(obj, self.MARKER, self.counter)
    ...             self.data[self.counter] = obj
    ...             intid = self.counter
    ...             self.counter += 1
    ...         return intid
    ...     def getObject(self, intid):
    ...         return self.data[intid]
    ...     def __iter__(self):
    ...         return iter(self.data)
    ...
    >>> intid = DummyIntId()
    >>> component.provideUtility(
    ...     intid, zope.app.intid.interfaces.IIntIds)
    >>> import sets
    >>> from zope.app.container.interfaces import IContained
    >>> class DummyIndex(object):
    ...     interface.implements(IContained)
    ...     __parent__ = __name__ = None
    ...     def __init__(self):
    ...         self.uids = sets.Set()
    ...     def unindex_doc(self, uid):
    ...         self.uids.discard(uid)
    ...     def index_doc(self, uid, obj):
    ...         self.uids.add(uid)
    ...     def clear(self):
    ...         self.uids.clear()
    ...
    >>> class DummyContent(object):
    ...     pass
    ...
    >>> content = {}
    >>> for i in range(100):
    ...     c = DummyContent()
    ...     content[intid.register(c)] = c
    ...
    >>> def filter(extent, uid, ob):
    ...     assert interfaces.IExtent.providedBy(extent)
    ...     assert getattr(ob, DummyIntId.MARKER) == uid
    ...     # This is an extent of objects with odd-numbered uids without a
    ...     # True ignore attribute
    ...     return uid % 2 and not getattr(ob, 'ignore', False)
    >>> extent = extentcatalog.FilterExtent(filter)
    >>> verify.verifyObject(interfaces.IFilterExtent, extent)
    True
    >>> catalog = extentcatalog.Catalog(extent)
    >>> verify.verifyObject(interfaces.IExtentCatalog, catalog)
    True
    >>> index = DummyIndex()
    >>> catalog['index'] = index

Now we have a catalog set up with an index and an extent, and some content to
index.  If we ask the catalog to index all of the content, only the ones that
match the filter will be in the extent and in the index.

    >>> for c in content.values():
    ...     catalog.index_doc(intid.register(c), c)
    ...
    >>> matches = sorted(
    ...     [id for id, ob in content.items() if filter(extent, id, ob)])
    >>> sorted(extent) == sorted(index.uids) == matches
    True

If a content object is indexed that used to match the filter but no longer
does, it should be removed from the extent and indexes.

    >>> 5 in catalog.extent
    True
    >>> content[5].ignore = True
    >>> catalog.index_doc(5, content[5])
    >>> 5 in catalog.extent
    False
    >>> matches.remove(5)
    >>> sorted(extent) == sorted(index.uids) == matches
    True

Unindexing an object that is in the catalog should simply remove it from the
catalog and index as usual.

    >>> 99 in catalog.extent
    True
    >>> 99 in catalog['index'].uids
    True
    >>> catalog.unindex_doc(99)
    >>> 99 in catalog.extent
    False
    >>> 99 in catalog['index'].uids
    False
    >>> matches.remove(99)
    >>> sorted(extent) == sorted(index.uids) == matches
    True

And similarly, unindexing an object that is not in the catalog should be a
no-op.

    >>> 0 in catalog.extent
    False
    >>> catalog.unindex_doc(0)
    >>> 0 in catalog.extent
    False
    >>> sorted(extent) == sorted(index.uids) == matches
    True

Clearing the catalog clears both the extent and the contained indexes.

    >>> catalog.clear()
    >>> list(catalog.extent) == list(catalog['index'].uids) == []
    True

Updating all indexes and an individual index both also update the extent.

    >>> catalog.updateIndexes()
    >>> matches.append(99)
    >>> sorted(extent) == sorted(index.uids) == matches
    True
    >>> index2 = DummyIndex()
    >>> catalog['index2'] = index2
    >>> index.uids.remove(1) # to confirm that only index 2 is touched
    >>> catalog.updateIndex(index2)
    >>> sorted(extent) == sorted(index2.uids) == matches
    True
    >>> 1 in index.uids
    False
    >>> 1 in index2.uids
    True
    >>> index.uids.add(1) # normalize things again.

If you update a single index and an object is no longer a member of the extent,
it is removed from all indexes.

    >>> 1 in catalog.extent
    True
    >>> 1 in index.uids
    True
    >>> 1 in index2.uids
    True
    >>> content[1].ignore = True
    >>> catalog.updateIndex(index2)
    >>> 1 in catalog.extent
    False
    >>> 1 in index.uids
    False
    >>> 1 in index2.uids
    False
    >>> matches.remove(1)
    >>> matches == sorted(catalog.extent)
    True

The extent itself provides a number of merging features to allow its values to
be merged with other BTrees.IFBTree data structures.  These include
intersection, union, difference, and reverse difference.  Given an extent
named 'extent' and another IFBTree data structure named 'data', intersections
can be spelled "extent & data" or "data & extent"; unions can be spelled
"extent | data" or "data | extent"; differences can be spelled "extent - data";
and reverse differences can be spelled "data - extent".  Unions and
intersections are weighted.

    >>> from BTrees import IFBTree
    >>> alt_set = IFBTree.IFTreeSet()
    >>> alt_set.update(range(0, 166, 33)) # return value is unimportant here
    6
    >>> sorted(alt_set)
    [0, 33, 66, 99, 132, 165]
    >>> sorted(catalog.extent & alt_set)
    [33, 99]
    >>> sorted(alt_set & catalog.extent)
    [33, 99]
    >>> sorted(catalog.extent.intersection(alt_set))
    [33, 99]
    >>> union_matches = sets.Set(matches)
    >>> union_matches.union_update(alt_set)
    >>> union_matches = sorted(union_matches)
    >>> sorted(alt_set | catalog.extent) == union_matches
    True
    >>> sorted(catalog.extent | alt_set) == union_matches
    True
    >>> sorted(catalog.extent.union(alt_set)) == union_matches
    True
    >>> sorted(alt_set - catalog.extent)
    [0, 66, 132, 165]
    >>> sorted(catalog.extent.rdifference(alt_set))
    [0, 66, 132, 165]
    >>> matches.remove(33)
    >>> matches.remove(99)
    >>> sorted(catalog.extent - alt_set) == matches
    True
    >>> sorted(catalog.extent.difference(alt_set)) == matches
    True


Self-populating extents
-----------------------

An extent use the initialize an extent catalog may know how to
populate itself; this is especially useful if the catalog can be
initialized with fewer items than those available in the IIntIds
utility that are also within the nearest Zope 3 site (the policy coded
in the basic Zope 3 catalog).

The such an extent must implement the `ISelfPopulatingExtent`
interface, which requires two attributes.  Let's use the
`FilterExtent` class as a base for implementing such an extent, with a
method that selects object 42 (created and registered above)::

    >>> class PopulatingExtent(extentcatalog.FilterExtent):
    ...
    ...     interface.implements(interfaces.ISelfPopulatingExtent)
    ...
    ...     populated = False
    ...
    ...     def populate(self):
    ...         if self.populated:
    ...             return
    ...         self.add(42, content[42])
    ...         self.populated = True

Creating a catalog based on this extent ignores objects in the
database already::

    >>> def accept_any(extent, uid, ob):
    ...     return True

    >>> extent = PopulatingExtent(accept_any)
    >>> catalog = extentcatalog.Catalog(extent)
    >>> index = DummyIndex()
    >>> catalog['index'] = index

At this point, our extent remains unpopulated::

    >>> extent.populated
    False

Iterating over the extent does not cause it to be automatically
populated::

    >>> list(extent)
    []

Causing our new index to be filled will cause the `populate()` method
to be called, setting the `populate` flag as a side-effect::

    >>> catalog.updateIndex(index)
    >>> extent.populated
    True

    >>> list(extent)
    [42]

The index has been updated with the documents identified by the
extent::

    >>> index.uids
    Set([42])

Updating the same index repeatedly will continue to use the extent as
the source of documents to include::

    >>> catalog.updateIndex(index)

    >>> list(extent)
    [42]
    >>> index.uids
    Set([42])

The `updateIndexes()` method has a similar behavior.  If we add an
additional index to the catalog, we see that it indexes only those
objects from the extent::

    >>> index2 = DummyIndex()
    >>> catalog['index2'] = index2

    >>> catalog.updateIndexes()

    >>> list(extent)
    [42]
    >>> index.uids
    Set([42])
    >>> index2.uids
    Set([42])

When we have fresh catalog and extent (not yet populated), we see that
`updateIndexes()` will cause the extent to be populated::

    >>> extent = PopulatingExtent(accept_any)
    >>> catalog = extentcatalog.Catalog(extent)
    >>> index1 = DummyIndex()
    >>> index2 = DummyIndex()
    >>> catalog['index1'] = index1
    >>> catalog['index2'] = index2

    >>> extent.populated
    False

    >>> catalog.updateIndexes()

    >>> extent.populated
    True

    >>> list(extent)
    [42]
    >>> index.uids
    Set([42])
    >>> index2.uids
    Set([42])


Let's clean up behind ourselves::

    >>> from zope.app.testing import ztapi
    >>> ztapi.unprovideUtility(zope.app.intid.interfaces.IIntIds)
